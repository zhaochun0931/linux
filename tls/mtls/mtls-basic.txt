Mutual TLS (mTLS) is a security mechanism where both the client and the server authenticate each other using TLS certificates.

Itâ€™s like HTTPS, but two-way:


ğŸš€
TLS (normal HTTPS):

Client verifies server certificate.

Server does NOT verify client certificate.

Only the server proves its identity.



ğŸš€
mTLS (mutual TLS):

Client verifies server certificate.

Server verifies client certificate.

Both sides prove their identity â†’ â€œmutualâ€.








ğŸ” How does mTLS work?
1ï¸âƒ£ A Certificate Authority (CA) signs both:

server.crt

client.crt

Both certificates trust the same CA (or CA chain).




2ï¸âƒ£ Client â†’ Server:

Client sends ClientHello + supported TLS features.

3ï¸âƒ£ Server â†’ Client:

Server sends:

server.crt

proof of private key (TLS handshake)

Client verifies:

Is the certificate signed by the CA?

Does the hostname match the SAN?

Is the certificate valid?





4ï¸âƒ£ Server requests client certificate:

Server: â€œPlease send your cert.â€

Client sends:

client.crt

proof of private key

Server verifies:

cert signed by same CA

contains allowed Extended Key Usage (EKU)

allowed subject (if configured)

ğŸ“Œ mTLS Requirements
âœ” Server certificate
Extended Key Usage: TLS Web Server Authentication

âœ” Client certificate
Extended Key Usage: TLS Web Client Authentication

âœ” Server must require client cert:

Nginx: ssl_verify_client on;

Golang: ClientAuth: tls.RequireAndVerifyClientCert

RabbitMQ: ssl_options.verify = verify_peer



