When a new process is created in Linux (or most Unix-like systems), a series of well-defined steps happens at the kernel level. Let me break it down carefully and clearly:

1. Forking a process

System call used: fork() (or clone() internally in Linux).

What happens:

The kernel allocates a new process descriptor (task_struct).

The new process gets a unique PID.

It inherits almost all attributes from the parent:

Open file descriptors

Memory space (copy-on-write)

Environment variables

Signal handlers

The new process starts execution from the point where fork() returns.

fork() returns 0 in the child, and child PID in the parent.

Example:

pid_t pid = fork();
if(pid == 0) {
    printf("Child process\n");
} else {
    printf("Parent process, child PID = %d\n", pid);
}

2. Replacing the process image

System call used: exec() family (execl, execvp, etc.).

What happens:

The child process replaces its entire memory image with a new program.

Code, data, heap, and stack are replaced.

The PID remains the same, but it now runs a different program.

If exec() fails, the old program continues.

Example:

char *args[] = {"ls", "-l", NULL};
execvp("ls", args);  // replaces current process with 'ls'

3. Using system()

system() is a higher-level wrapper that does:

fork() a new child process.

The child process runs /bin/sh -c "your command".

The parent waits for the child to finish.

Effectively, it’s like doing fork + exec + wait in one call.

4. Kernel internals

The scheduler decides when the new process runs.

Processes are managed as task_struct structures in the kernel.

Each process has:

PID (process ID)

PPID (parent PID)

Open files table

Memory map

CPU registers saved during context switch

5. What you observe

The new process gets a unique PID.

It may run concurrently with the parent.

Parent can wait for it using wait() or waitpid().

Resources (like files) may be shared or copied-on-write.






| Aspect           | fork()                   | exec()                     | system()                      |
| ---------------- | ------------------------ | -------------------------- | ----------------------------- |
| Creates new PID  | ✅                        | ❌ (same PID)               | ✅                             |
| Runs new program | ❌ (same code as parent)  | ✅ (replaces process image) | ✅ (via `/bin/sh`)             |
| Parent affected  | Can wait for child       | No                         | Can wait                      |
| Typical usage    | Create process hierarchy | Run a new program          | Quick shell command execution |








Time -->
Parent PID=1000
|
| fork()
v
Parent PID=1000                Child PID=1001
|                              |
|                              |  (child starts at same code point as parent)
|                              |  printf("Child running")
| wait()                       |
v                              v
Parent continues               exec("ls")
|                              |
|                              |  (memory replaced, now running 'ls')
|                              |
v                              v
Parent PID=1000                Child PID=1001
|                              |
| system("echo Hello")         |
|                              |
|                              fork() inside system()
|                              Child PID=1002
|                              |
|                              execl("/bin/sh", "-c", "echo Hello")
|                              Hello printed
|                              exit()
v
system() returns to parent
Parent PID=1000



Explanation

fork()

Creates a new child PID=1001.

Child is an exact copy of parent (memory, file descriptors, etc.).

Parent can continue or wait for the child.

exec()

Replaces child’s memory with a new program (e.g., ls).

PID remains the same (1001), but code/data are replaced.

Parent still PID=1000, waits if desired.

system()

Parent calls system().

Internally does fork() → new PID=1002.

Child runs /bin/sh -c "echo Hello".

Child exits, parent resumes.







Parent Process (PID=1000)
│
├── fork() → Child Process (PID=1001)
│       ├─ Runs same code as parent initially
│       └─ exec("ls") → replaces memory, still PID=1001
│
└── system("echo Hello") 
        ├─ Internally fork() → Child Process (PID=1002)
        │       └─ execl("/bin/sh -c echo Hello") → runs command
        └─ Child exits → system() returns to parent



Legend

fork(): Creates a new process with a new PID.

exec(): Replaces a process’s memory with a new program (PID stays the same).

system(): Convenience function that does fork + exec internally, then waits for the child.















Step 0: Initial Parent Process
Parent PID=1000
Code: main()

Step 1: fork()
Parent PID=1000             Child PID=1001
Code: main()                Code: main()  (starts at fork() return)
fork() returns child PID     fork() returns 0

Step 2: Child executes exec()
Parent PID=1000             Child PID=1001
Code: main()                Code replaced by 'ls'
                            (exec replaces memory, still PID=1001)

Step 3: Parent calls system("echo Hello")
Parent PID=1000
Code: system("echo Hello")

Step 4: system() internally forks
Parent PID=1000             Child PID=1002
Code: waiting inside system Code: /bin/sh -c "echo Hello"

Step 5: system() child executes command
Parent PID=1000             Child PID=1002
Code: waiting               Code: prints "Hello"

Step 6: system() child exits
Parent PID=1000             Child PID=1002
Code: resumes after system() Child terminated

Step 7: Parent continues
Parent PID=1000
Code: continues main()


✅ Key points from this flow:

fork() creates a new PID; parent and child run concurrently.

exec() replaces the child process memory without changing PID.

system() is just fork + exec + wait in one call.

Parent can continue or wait depending on your code (wait() or system()).












