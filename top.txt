top

top -H













Some useful options and keypresses:

q: Quit the top command.
P: Sort processes by CPU usage.
M: Sort processes by memory usage.
1: Toggle CPU core display (shows per-core CPU usage).
d: Change the update interval (default is 3 seconds)





top - 10:32:15 up 2 days,  4:13,  1 user,  load average: 0.01, 0.05, 0.08
Tasks: 149 total,   1 running, 148 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.1 us,  0.3 sy,  0.0 ni, 98.3 id,  0.0 wa,  0.1 hi,  0.1 si,  0.0 st
MiB Mem :   7992.5 total,   3420.7 free,   2721.3 used,   2850.5 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   5459.1 avail Mem



Breakdown:
Time: 10:32:15 ‚Äî The current system time.

Uptime: up 2 days, 4:13 ‚Äî The system has been running for 2 days and 4 hours.

User count: 1 user ‚Äî There is currently 1 user logged in.

Load averages: load average: 0.01, 0.05, 0.08 ‚Äî This shows the load averages over the last 1, 5, and 15 minutes. The load average is an indicator of how many processes are actively running or waiting for CPU resources. A value of 1.0 per CPU core is generally considered fully utilized, but these numbers should be interpreted in context with the number of CPU cores.

Tasks: 149 total ‚Äî Total number of tasks (processes).

1 running ‚Äî How many processes are currently running.
148 sleeping ‚Äî How many are waiting for something (e.g., I/O operations).
0 stopped ‚Äî How many are stopped.
0 zombie ‚Äî How many are in a "zombie" state (terminated but not cleaned up).
CPU Usage: 1.1 us, 0.3 sy, 0.0 ni, 98.3 id, 0.0 wa, 0.1 hi, 0.1 si, 0.0 st

us (user): 1.1% ‚Äî Time spent on user-level tasks (applications).
sy (system): 0.3% ‚Äî Time spent on kernel-level tasks (system calls).
ni (nice): 0.0% ‚Äî Time spent on processes with a modified priority (nice value).
id (idle): 98.3% ‚Äî Time the CPU is idle.
wa (waiting): 0.0% ‚Äî Time spent waiting for I/O operations.
hi (hardware interrupts): 0.1% ‚Äî Time the CPU spends handling hardware interrupts.
si (software interrupts): 0.1% ‚Äî Time spent handling software interrupts.
st (steal time): 0.0% ‚Äî Time the virtual CPU spends waiting for real CPU resources from the hypervisor (relevant in virtualized environments).
Memory Usage:

total: The total amount of physical memory (RAM).
free: The amount of free memory available.
used: The amount of memory being actively used.
buff/cache: Memory used by buffers or cache (used to improve performance).
Swap Usage:

total: The total amount of swap space.
free: How much swap space is free.
used: How much swap space is in use.
avail Mem: The total memory available, including swap and free RAM.



2. Process List (Bottom part)
This section shows the currently running processes on your system.

Example output:

PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
12345 user     20   0  123456  23456   1234 S  0.0  0.3   0:01.23 bash
67890 user     20   0  345678  45678   2345 S  1.2  0.5   1:23.45 firefox


Columns:
PID: The Process ID. A unique number assigned to each running process.
USER: The user who owns the process.
PR: The process priority. Higher values indicate lower priority (lower number = higher priority).
NI: The "nice" value of the process, which affects its priority.
VIRT: The total virtual memory used by the process (includes memory that has been swapped out).
RES: The resident memory (RAM) used by the process (memory that is actually in RAM).
SHR: The shared memory used by the process.
S: The process status. Common values are:
S for sleeping (waiting for resources).
R for running.
Z for zombie (terminated but not cleaned up).
T for stopped (either by a signal or a debugger).
%CPU: The percentage of CPU being used by the process.
%MEM: The percentage of RAM being used by the process.
TIME+: The total CPU time the process has consumed since it started.
COMMAND: The name of the command running (or the executable).







For a Java process, the Resident Set Size (RSS) and Java Heap memory are two different views of memory usage:
RSS is the operating system's view of how much physical RAM the entire Java process is currently occupying.
Java Heap is the Java Virtual Machine's (JVM) view of the memory it is managing for Java application objects. 
The Java heap is a subset of the total memory used by the Java process. The RSS will always be greater than or equal to the heap size. 

Here is a detailed breakdown of the differences:
RSS (Operating System View)
Definition: The total amount of physical memory (RAM) that the Java process is using. This includes all memory allocated for the JVM, not just the heap.
What it includes:
Java Heap: The memory managed by the Garbage Collector.
Metaspace: Stores class metadata, including methods and fields.
Thread Stacks: Each thread has its own stack memory.
Code Cache: The memory where the Just-In-Time (JIT) compiler stores compiled machine code.
Native Memory: Any off-heap memory allocated by the JVM for internal use or by native libraries through the Java Native Interface (JNI).
Control: RSS is managed by the operating system. You cannot directly control it with JVM options, but you can control its components (like the heap and metaspace) which in turn affect the total RSS.
Behavior: RSS can be deceiving because it over-counts memory shared between processes, such as shared libraries. Also, a Java process might reserve a large chunk of memory upfront, but its RSS only grows as the process actually uses and touches that memory. 
Java Heap (JVM View)
Definition: The dedicated memory pool within the Java process where all objects created by a running Java application are stored.
What it includes: Only the objects created by your Java application code.
Control: The heap size is controlled by JVM command-line options such as -Xms (initial size) and -Xmx (maximum size).
Behavior:
Garbage Collection: The JVM's Garbage Collector automatically manages the heap, reclaiming memory from objects that are no longer in use.
Memory Leaks: If a Java application object is never released, it can cause a memory leak, leading to an OutOfMemoryError even if the total process RSS is still within system limits.
GC Pauses: A very large heap can increase the pause times during garbage collection, which can affect application performance.










let‚Äôs do a step-by-step reconciliation of what top shows (RES) vs what JVM reports (NativeMemoryTracking).

üîπ Step 1. Find your Java process
ps -ef | grep java


or directly:

top -p <pid>


Take note of PID and RES (Resident memory).

Example:

  PID USER   PR NI VIRT   RES   SHR S %CPU %MEM COMMAND
12345 java   20  0 20g   12g   1g  S  100  60  java


Here, RSS (RES) = 12 GB.

üîπ Step 2. Enable Native Memory Tracking (NMT)

When starting Java, add:

-XX:NativeMemoryTracking=summary


If your JVM is already running without this flag, you won‚Äôt see breakdowns.
(If possible, restart with the flag.)

üîπ Step 3. Dump JVM native memory

Run:

jcmd <pid> VM.native_memory summary


Example output:

Native Memory Tracking:

Total: reserved=20480MB, committed=12200MB
-                 Java Heap (reserved=8192MB, committed=4096MB)
-                     Class (reserved=1200MB, committed=1200MB)
-                    Thread (reserved=800MB, committed=800MB)
-                      Code (reserved=512MB, committed=512MB)
-                        GC (reserved=2048MB, committed=2048MB)
-                  Compiler (reserved=256MB, committed=256MB)
-                  Internal (reserved=384MB, committed=384MB)
-                   Symbol (reserved=100MB, committed=100MB)
-    Native Memory Tracking (reserved=8MB, committed=8MB)
-               Arena Chunk (reserved=700MB, committed=700MB)

üîπ Step 4. Reconcile with top

top said: 12 GB RSS

NMT said: committed=12200MB

‚úÖ They match! (RES ‚âà committed)

Breakdown:

Java Heap = 4 GB (inside JVM reports low heap usage)

Class/Metaspace = 1.2 GB

Threads = 0.8 GB

GC structures = 2 GB

Code cache, compiler, etc. = ~1.2 GB

Native buffers (Arena) = 0.7 GB

‚Üí Adds up to 12 GB (what top shows).

So even though the heap is 4 GB, the process reserves many extra areas, which explains the high %MEM.

üîπ Step 5. Optional: Inspect at OS level

If you don‚Äôt have NMT, you can peek with pmap:

pmap -x <pid> | less


Look for sections like:

[heap]

anon (thread stacks, arenas, malloc)

mapped .so libraries

‚úÖ That‚Äôs how you reconcile %MEM from top with actual JVM usage.
The key idea: RSS = Heap + Non-heap (Metaspace, CodeCache, Stacks, Direct Buffers, GC, JNI, etc.)




















üîπ top Columns (Linux)

VIRT (Virtual Memory Size)

Total address space reserved by the process.

Includes heap, thread stacks, code cache, shared libs, and even memory-mapped files.

Maps to JVM ‚ÄúReserved‚Äù memory (but not 1:1, since OS + libraries also add overhead).

RES (Resident Set Size)

The portion of VIRT that is actually committed in RAM (backed by physical memory).

Maps to JVM ‚ÄúCommitted‚Äù memory.

SHR (Shared Memory)

Part of RES that is shared with other processes (e.g., shared libraries, kernel mappings).

JVM doesn‚Äôt report this explicitly, but it shows up in RES.

üîπ Example with your numbers

top snapshot:

PID USER      VIRT    RES    SHR S  %MEM COMMAND
86790 root   3143980 124160 22920 S   3.1 java


VIRT = 3143980 KB ‚âà 3.0 GB
‚Üí JVM reserved space + shared libs + mmap files.
‚Üí Matches NMT Reserved ~ 1.9 GB (plus OS overhead).

RES = 124160 KB ‚âà 121 MB
‚Üí JVM committed memory (plus some native).
‚Üí Matches NMT Committed ~ 160 MB (close, depending on timing + accounting).

SHR = 22920 KB ‚âà 22 MB
‚Üí Mostly shared libc, JVM libs, etc.

üîπ Takeaway

VIRT = Reserved (upper bound)

RES = Committed (real RAM used)

SHR = Shared part of RES

That‚Äôs why:

JVM heap might be only 14 MB committed,

But top shows 121 MB RES ‚Äî because threads, code cache, class metadata, and other JVM internals are also committed.
