top

top -H













Some useful options and keypresses:

q: Quit the top command.
P: Sort processes by CPU usage.
M: Sort processes by memory usage.
1: Toggle CPU core display (shows per-core CPU usage).
d: Change the update interval (default is 3 seconds)





top - 10:32:15 up 2 days,  4:13,  1 user,  load average: 0.01, 0.05, 0.08
Tasks: 149 total,   1 running, 148 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.1 us,  0.3 sy,  0.0 ni, 98.3 id,  0.0 wa,  0.1 hi,  0.1 si,  0.0 st
MiB Mem :   7992.5 total,   3420.7 free,   2721.3 used,   2850.5 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   5459.1 avail Mem



Breakdown:
Time: 10:32:15 â€” The current system time.

Uptime: up 2 days, 4:13 â€” The system has been running for 2 days and 4 hours.

User count: 1 user â€” There is currently 1 user logged in.

Load averages: load average: 0.01, 0.05, 0.08 â€” This shows the load averages over the last 1, 5, and 15 minutes. The load average is an indicator of how many processes are actively running or waiting for CPU resources. A value of 1.0 per CPU core is generally considered fully utilized, but these numbers should be interpreted in context with the number of CPU cores.

Tasks: 149 total â€” Total number of tasks (processes).

1 running â€” How many processes are currently running.
148 sleeping â€” How many are waiting for something (e.g., I/O operations).
0 stopped â€” How many are stopped.
0 zombie â€” How many are in a "zombie" state (terminated but not cleaned up).
CPU Usage: 1.1 us, 0.3 sy, 0.0 ni, 98.3 id, 0.0 wa, 0.1 hi, 0.1 si, 0.0 st

us (user): 1.1% â€” Time spent on user-level tasks (applications).
sy (system): 0.3% â€” Time spent on kernel-level tasks (system calls).
ni (nice): 0.0% â€” Time spent on processes with a modified priority (nice value).
id (idle): 98.3% â€” Time the CPU is idle.
wa (waiting): 0.0% â€” Time spent waiting for I/O operations.
hi (hardware interrupts): 0.1% â€” Time the CPU spends handling hardware interrupts.
si (software interrupts): 0.1% â€” Time spent handling software interrupts.
st (steal time): 0.0% â€” Time the virtual CPU spends waiting for real CPU resources from the hypervisor (relevant in virtualized environments).
Memory Usage:

total: The total amount of physical memory (RAM).
free: The amount of free memory available.
used: The amount of memory being actively used.
buff/cache: Memory used by buffers or cache (used to improve performance).
Swap Usage:

total: The total amount of swap space.
free: How much swap space is free.
used: How much swap space is in use.
avail Mem: The total memory available, including swap and free RAM.



2. Process List (Bottom part)
This section shows the currently running processes on your system.

Example output:

PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND
12345 user     20   0  123456  23456   1234 S  0.0  0.3   0:01.23 bash
67890 user     20   0  345678  45678   2345 S  1.2  0.5   1:23.45 firefox


Columns:
PID: The Process ID. A unique number assigned to each running process.
USER: The user who owns the process.
PR: The process priority. Higher values indicate lower priority (lower number = higher priority).
NI: The "nice" value of the process, which affects its priority.
VIRT: The total virtual memory used by the process (includes memory that has been swapped out).
RES: The resident memory (RAM) used by the process (memory that is actually in RAM).
SHR: The shared memory used by the process.
S: The process status. Common values are:
S for sleeping (waiting for resources).
R for running.
Z for zombie (terminated but not cleaned up).
T for stopped (either by a signal or a debugger).
%CPU: The percentage of CPU being used by the process.
%MEM: The percentage of RAM being used by the process.
TIME+: The total CPU time the process has consumed since it started.
COMMAND: The name of the command running (or the executable).








letâ€™s do a step-by-step reconciliation of what top shows (RES) vs what JVM reports (NativeMemoryTracking).

ðŸ”¹ Step 1. Find your Java process
ps -ef | grep java


or directly:

top -p <pid>


Take note of PID and RES (Resident memory).

Example:

  PID USER   PR NI VIRT   RES   SHR S %CPU %MEM COMMAND
12345 java   20  0 20g   12g   1g  S  100  60  java


Here, RSS (RES) = 12 GB.

ðŸ”¹ Step 2. Enable Native Memory Tracking (NMT)

When starting Java, add:

-XX:NativeMemoryTracking=summary


If your JVM is already running without this flag, you wonâ€™t see breakdowns.
(If possible, restart with the flag.)

ðŸ”¹ Step 3. Dump JVM native memory

Run:

jcmd <pid> VM.native_memory summary


Example output:

Native Memory Tracking:

Total: reserved=20480MB, committed=12200MB
-                 Java Heap (reserved=8192MB, committed=4096MB)
-                     Class (reserved=1200MB, committed=1200MB)
-                    Thread (reserved=800MB, committed=800MB)
-                      Code (reserved=512MB, committed=512MB)
-                        GC (reserved=2048MB, committed=2048MB)
-                  Compiler (reserved=256MB, committed=256MB)
-                  Internal (reserved=384MB, committed=384MB)
-                   Symbol (reserved=100MB, committed=100MB)
-    Native Memory Tracking (reserved=8MB, committed=8MB)
-               Arena Chunk (reserved=700MB, committed=700MB)

ðŸ”¹ Step 4. Reconcile with top

top said: 12 GB RSS

NMT said: committed=12200MB

âœ… They match! (RES â‰ˆ committed)

Breakdown:

Java Heap = 4 GB (inside JVM reports low heap usage)

Class/Metaspace = 1.2 GB

Threads = 0.8 GB

GC structures = 2 GB

Code cache, compiler, etc. = ~1.2 GB

Native buffers (Arena) = 0.7 GB

â†’ Adds up to 12 GB (what top shows).

So even though the heap is 4 GB, the process reserves many extra areas, which explains the high %MEM.

ðŸ”¹ Step 5. Optional: Inspect at OS level

If you donâ€™t have NMT, you can peek with pmap:

pmap -x <pid> | less


Look for sections like:

[heap]

anon (thread stacks, arenas, malloc)

mapped .so libraries

âœ… Thatâ€™s how you reconcile %MEM from top with actual JVM usage.
The key idea: RSS = Heap + Non-heap (Metaspace, CodeCache, Stacks, Direct Buffers, GC, JNI, etc.)
